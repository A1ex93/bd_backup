# Домашнее задание к занятию "`Резервное копирование.`" - `Gurylev A.V.`


## Задание 1. Резервное копирование

## 1.1. Восстановление данных в полном объёме за предыдущий день
Решение: Ежедневное полное резервное копирование (full backup).  
Каждый день создаётся полная копия всей базы данных. Это позволяет восстановить данные на момент конца предыдущего дня.

## 1.2. Восстановление данных за час до поломки
Решение: Смешанная стратегия — полное + инкрементное/дифференциальное резервное копирование.  
Еженедельно или ежедневно делается полная копия, а затем каждые несколько часов — инкрементные копии (только изменения с момента последней копии). Это позволяет восстановить данные с точностью до часа.

## 1.3.Моментальное переключение при поломке
Да, возможен. Это реализуется через репликацию БД и автоматическое переключение (failover):  
- Используются реплики БД в режиме реального времени.
- При падении основной базы подключается **hot standby** или **активная реплика**.
- Технологии: Patroni, repmgr для PostgreSQL; MySQL Group Replication или InnoDB Cluster.

## Задание 2. PostgreSQL

## 2.1. Пример команд pg_dump / pg_restore

# Резервное копирование
pg_dump -U пользователь -h localhost -F c dbname > backup.dump

# Восстановление
pg_restore -U пользователь -h localhost -d dbname -v backup.dump

## 2.1. Автоматизация процесса
Да, возможна.
- Через cron (Linux) создать скрипт резервного копирования с датой в имени файла.
- Добавить логирование, проверку успешности, удаление старых бэкапов.
- Можно использовать утилиты вроде pgBackRest, Barman для продвинутого управления.

## Задание 3. MySQL

## 3.1. Инкрементное резервное копирование MySQL
MySQL не имеет встроенного инкрементного бэкапа, но его можно реализовать с помощью Percona XtraBackup:

# Полный бэкап
xtrabackup --backup --user=root --password=pass --target-dir=/backups/base

# Инкрементный бэкап
xtrabackup --backup --user=root --password=pass --target-dir=/backups/inc1 --incremental-basedir=/backups/base

## 3.1. Когда репликация лучше резервного копирования?
- При высокой нагрузке и низком допуске на потерю данных (RPO ~ 0).
- Для горизонтального масштабирования чтения (read replicas).
- Для аварийного переключения (failover) без потерь.
- При необходимости минимизации downtime во время восстановления.
